学习笔记

(我用typora编辑的，直接截图然后粘贴到md上的，图片没有一起上传，应该看不到图吧，我才注意到这个问题，有时间处理一下。还有就是这周事情太多了，笔记有点糙，好多内容没来得及写上去)

## 一、map

### 1、hashmap是什么？

**定义**：哈希表也是散列表，就是键值对(key: value)，通过key访问value。

简单原理：把key通过散列函数映射到表中的一个位置，然后相当于通过索引进行查找value。

![image-20201129235640367](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201129235640367.png)

### 2、冲突解决

这种映射到表中的形式可能会产生冲突，也就是多个key映射到一个索引上。

解决方案(缓解查找时间变长)：

开放寻址法：遇到冲突时，就向后循环查找，直到找到一个空位置插入。

拉链法：key经过哈希函数后得到索引，这个索引存链表的头结点，如果遇到冲突就直接在该位置上的链表增加节点。

### 3、加载因子

上面说到hashmap是将key映射到表里(数组)，这个表有长度，这个表越满，冲突概率越高。如果到了一定程度，就需要将这个表进行扩容。但是什么时候进行扩容呢？这时就需要加载因子了。

加载因子：当已写入容量超过(总容量X加载因子)的时候就需要扩容。一般设为0.75。

## 二、树

### 1、二叉树

这个图针不戳，很清晰。

![image-20201130001831328](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20201130001831328.png)

### 2、遍历

前序：父-左-右

中序：左-父-右

后序：左-右-父

### 3、二叉搜索树

性质：

- 左子树上的所有节点的值都小于根节点的值；
- 右子树上的所有节点的值都大于根节点的值；

其中序遍历就是升序排列

## 三、堆

### 1、堆是什么

快速找到一堆数中最大或者最小值。

堆不一定就是二叉堆，还有很多。

二叉堆中，根节点最大就是大顶堆，根节点最小就是小顶堆。

二叉堆通过完全二叉树实现(和二叉搜索树一点关系都没有)。

性质：

- 完全二叉树
- 大顶堆：所有的父节点都大于其子节点。
- 小顶堆：所有的父节点都小于其子节点。

### 2、二叉堆的实现

完全二叉树就可以通过数组实现，所以二叉堆也可以通过数组实现。

**如果根节点索引位置为0，各个节点的位置**：

- i的左子节点索引为(2*i+1)
- i的右子节点索引为(2*i+2)
- i的父节点为floor((i-1)/2)

### 3、堆的元素插入与弹出

**插入**（大顶堆）：

1、新节点放在树的最后，然后整理堆；

2、这个节点慢慢往上爬：比父节点大，就和父节点交换，直到比父节点小为止。

**弹出**（大顶堆）：弹出的一定是根节点，因为我们应该只想要最大值。

1、树的最后一个节点和根节点交换；

2、弹出最后一个节点，然后整理堆；

3、根节点慢慢往下降：这个节点不断和子节点中大的那个交换，直到比自己的两个子节点都大。

## 四、需要继续学习的内容

1、不同的hash：c++中的map和unordered_map

2、二叉树遍历代码实现(栈实现的)

3、堆的构建(不断插入)，弹出元素。

