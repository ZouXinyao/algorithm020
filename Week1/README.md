# 学习笔记

## 1、链表中需要注意的

- 链表一个node的value可以不是一个整数或者浮点数，也可以是其他类型的数据(比如1个类)。
- 头结点为head，尾结点为tail；
- 一个节点既有next指针，又有prev指针，这个就是双向链表；
- 尾结点的指针指向了头结点，就是循环链表；

## 2、数组和链表的增、删、查的时间复杂度

|        | 数组 | 链表 |
| ------ | ---- | ---- |
| insert | O(n) | O(1) |
| delete | O(n) | O(1) |
| find   | O(1) | O(n) |

注：这里有一个问题，有可能会产生这样的错误理解：链表在插入和删除节点的时候，需要找到要操作元素的位置，那么链表的insert和delete就不是O(1)了。

​		其实insert和delete这种操作都是建立在我们已经找到这个要操作的元素了，只是单纯的看insert和delete操作本身，不会考虑找元素的情况。

## 3、跳表

- 前提条件：跳表的元素必须**有序**！！！
- 跳表的基础结构也是**链表**。
- 跳表对标**平衡树**(二叉搜索树中的平衡树和二分查找)，插入、删除、搜索都是**O(log n)**
- 特点：原理简单、易实现、方便拓展、效率高。可以用来取代平衡树。



一种思想：**一维的数据结构想要加速，就可以通过提高维度来实现**，提高维度之后，信息更多。
另一种思想：**空间换时间**。



### 跳表的思想(增加多级索引)：

(这里要加一个图)

#### 查找过程：

1. 查找元素P的时候，可以先从最高级的索引进行查找；
2. 因为跳表有序，所以如果 当前元素值<P<下一元素值，会向下进行查找；
3. 同样是一个一个比较，如果出现上面的情况就继续向下，直到找到元素为止；
4. 如果在原始链表中没有找到该元素，说明这个跳表里没有这个元素。

#### 时间、空间复杂度：

- 跳表**查找的时间复杂度为O(log n)**，也就是跳表的级数，默认是一级跨两个元素。比如：第1级的两个元素之间会跨越原始链表的两级。
- 跳表的导致维护成本较高。当跳表增加删除节点时，会导致跳表有的地方跳两个元素，有的地方跳很多元素，这就导致了跳表的**增加、删除节点的时间复杂度为O(log n)**。
- **空间复杂度是O(n)**

## 4、应用：

链表的应用：LRU缓存

跳表的应用：Redis

## 5、总结：

数组和链表的时间复杂度，结合应用场景。

跳表主要以理解为主。

## 6、优化重点思想：

一种思想：**一维的数据结构想要加速，就可以通过提高维度来实现**，提高维度之后，信息更多。（**升维**）
另一种思想：**空间换时间**。



## 练习总结：

#### 嵌套循环：

`int length = height.size();
for(int i = 0; i < length; i++) {
	for(int j = i + 1; j < length; j++) {
    }`

#### 双指针中使用的循环：

`int j = height.size() - 1;
for(int i = 0; i < j;) {
	分情况进行j--，或者i++
}`

这里为什么要把j定义到外面，不在循环里？因为定义在循环里，每次都会计算height.size()，导致性能下降。

#### 不会时候的做题思维：

- 能不能暴力解决
- 从最基本的情况开始思考，然后开始泛化，就是找最近重复子问题。

